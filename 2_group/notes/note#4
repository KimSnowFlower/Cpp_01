포인터란?
객체의 주소 값을 가지는 변수이며,  C언어의 포인터와 동일하다.

포인터로 어떻게 멤버에 접근하는지를 알고 있지 않아, 포인터를 말로 설명하는 데 어려움을 겪었다.
-> 멤버에 접근하는 순서를 배움으로써, 포인터를 말로 설명하는 데 어려움을 해결할 수 있었다.
  
Circle *p;  // Circle 클래스를 불러와 p라는 객체 포인터를 선언한다.
p = &donut; // p에 도넛의 객체 주소를 저장한다.
p->getArea() // 도넛의 객체 중 getArea()함수 부분을 가진 p의 getArea() 함수를 호출한다.

객체 배열은 매개 변수 없는 생성자는 호출 할 수 없다. 
매개 변수 있는 생성자를 호출 할 경우 오류가 발생한다. 예) Circle circleArray[3](5); // 오류

Circle *p; // (3) //
p = circleArray; // (4)
for(int i=0; i<3; i++) { // 객체 포인터로 배열 접근
cout << "Circle " << i << "의 면적은 " << p->getArea() << endl;
p++; // 현재 p의 주소값 + 1 == 다음 배열의 주소 값

p의 주소값을 증가시켜주는 이유를 알지 못해 코드를 작성하는데 어려움을 겪었다.
-> p의 주소값을 증가시켜주는 이유 : 처음 배열 시작부분이 [0]부터 시작되기 때문이다.
   이를 통해 코드 작성의 어려움을 해결할 수 있었다.

(4) p = &circleArray; 가 아닌 이유 : 배열은 배열 자체에 주소값이 이미 정해져 있기 때문에 굳이 객체처럼 주소값(&)을 저장할 필요 없다.

※ 동적 메모리 할당 및 반환 방법
정적 할당
-> 변수 선언을 통해 필요한 메모리 할당
동적 할당
-> 필요한 양이 예측되지 않는 경우, 프로그램 작성시 할당 받을 수 없어, 실행 중에 힙 메모리에서 할당

※ C++의 동적 메모리 할당 
-> new 연산자(배열, 객체, 객체배열, 기본 타입 메모리 할당 등)
※ C++의 동적 메모리 반환
-> delete 연산자(new로 할당 받은 메모리 반환(소멸자 호출 뒤 객체를 힙에 반환)
   이때, delete 연산자를 사용할 경우 포인터는 살아있지만, 포인터를 가리키는 곳을 호출해서는 안된다는 것을 새롭게 알게 되었다.

배열은 동적 할당시 초기화가 불가능하다.




