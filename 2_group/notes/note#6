가상 함수
- virtual 키워드로 선언된 멤버 함수로, 동적 바인딩 지시어이며, 컴파일러에게 함수에 대한 호출 바인딩을 실행시간까지 미루도록 지시하는 함수이다.

함수 오버라이딩
- 파생 클래스에서 기본 클래스의 가상 함수와 동일한 이름의 함수 선언하는 것이다.
- 이를 통해 기본 클래스의 가상 함수의 존재감을 상실시키고, 파생 클래스에서 오버라이딩한 함수가 호출되도록 동적 바인딩 해준다.
- 오버라이딩 시 virtual 지시어 생략이 가능하며, 가상 함수의 접근 지정 (private, protected, public) 자유롭게 지정 가능하다.
Ex)

class Base {
public:
virtual void f() {     //가상 함수
cout << "Base::f() called" << endl;
   }
};

class Derived : public Base {
public:
virtual void f() {   // 오버라이딩
cout << "Derived::f() called" << endl; 
    }
};

- 이 코드에서는 객체에는 두 개의 함수 f()가 존재하지만, 함수 오버라이딩으로 인해, Base의 f()는 존재감을 잃고, 항상 Derived의 f()가 호출된다.

동적 바인딩
- 기본 클래스에 대한 포인터로 가상 함수를 호출하는 경우이며, 객체 내에 오버라이딩한 파생 클래스의 함수를 찾아 실행하는 것을 의미한다.

가상 소멸자
- 소멸자를 virtual 키워드로 선언하는 것이며, 소멸자 호출 시 동적 바인딩이 발생한다

순수 가상 함수
- 기본 클래스의 가상 함수 목적으로, 파생클래스에서 재정의할 함수를 알려주는 역할을 하며, 함수의 코드가 없고 선언만 있는 가상 멤버 함수이다.
Ex) 
class Shape {
public:
    virtual void draw()=0; // 순수 가상 함수 선언
};

추상 클래스
- 최소한 하나의 순수 가상 함수를 가진 클래스이며, 추상 클래스의 인스턴스를 생성할 목적이 아닌 상속에서 기본 클래스의 역할을 하기 위함이다.
Ex)
class Shape { // Shape은 추상 클래스
   Shape *next;
public:
   void paint() {
       draw();
}
virtual void draw() = 0; // 순수 가상 함수
};
void Shape::paint() {
    draw(); // 순수 가상 함수라도 호출은 할 수 있다.
}

또한, 추상 클래스는 온전한 클래스가 아니면 객체 생성이 불가능하다.
Ex) Shape shape; // 컴파일 오류
Shape *p = new Shape(); // 컴파일 오류

추상 클래스의 상속
- 추상 클래스를 단순 상속하면 자동 추상 클래스가 된다.

추상 클래스의 구현
- 추상 클래스를 상속받아 순수 가상 함수를 오버라이딩한다.

---------------------------------------------------------------------------------------------------------------------------------
여기까지 배운 결과, 오버로딩, 함수 재정의, 오버라이딩 이 세가지가 각각 어떻게 다른지에 대해서 뚜렷하게 아는 것이 굉장히 어려웠던 것 같다.
- 오버로딩: 매개 변수 타입이나 개수가 다르지만, 이름이 같은 함수들이 중복 작성되는 것
- 함수 재정의: 기본클래스의 멤버 함수를 파생 클래스에서 이름, 매개 변수 타입과 개수, 리턴 타입까지 완벽히 같은 원형으로 재작성하는 것
- 오버라이딩 : 기본 클래스의 가상 함수를 파생 클래스에서 이름, 매개 변수 타입과 개수, 리턴 타입까지 완벽히 같은 원형으로 재작성 하는 것

오버로딩은 이름이 같은 여러 개의 함수를 중복 작성하여 사용의 편의성을 향상시키기 위해 사용하고,
함수 재정의는 기본 클래스의 멤버 함수와 별도로 파생 클래스에서 필요하여 재작성하기 위해 사용하며,
오버라이딩은 기본 클래스에 구현된 가상 함수를 무시하고, 파생 클래스에서 새로운 기능으로 재작성하고자 하기 위해 사용되는 것이다.

이번 시간에는 가상함수와 추상클래스에 관해서 배우는 시간이었다. 하지만, 가상함수와 추상클래스 또한 중요하지만, 오버로딩과 함수 재정의, 오버라이딩의 차이점을 명확히 아는 것이 이번 수업의 핵심 포인트라고 생각하였다.
코딩에서 실질적으로 활용하기 위해서 이 세가지의 차이점을 명확히 공부해야할 필요성을 느꼈던 수업이었던 것 같다.

