작성자 : 202004035 김평화

<객체의 캡슐화?>
우리가 알약에 내부를 볼 수 없는 것처럼 내부를 보호하고 볼 수 없게 하는 것

<캡슐화는 왜 하는 것일까?>
객체를 상태와 행동으로 분류가 가능한데
우리가 생각하기엔 내부적인 요소가 사용자를 통해
값이 지속적으로 변경되거나 외부에서 코드의 개입이 있기 때문에
캡슐화를 통해 객체의 일부분만 보이는 것은 매우 중요한 역할이라고 봅니다.

<클래스와 객체>
클래스는 집을 지을 때 만든 설계도면이라 하고
객체는 설계도면을 보고 만들어진 각 호수를 생각하면
매우 이해하기가 빨랐다.

클래스는 객체를 형성화하기 위한 구조를 짜는 것이라고 생각합니다.

<클래스>
class 키워드를 사용
자바에서 배웠던 private, public, protected 그대로 사용해서 이해하기 편했고
private의 경우 class 안에 객체나 함수를 작성할 때 public이나 protected를 사용하지 않으면 
기본적으로 private이라는 것을 수업중에 배웠지만 private를 안 쓰는 것보단 써서 정확히 구분을 하는 것이
코드를 작성할 때 보기 편하고 페어 프로그래밍 조원이 내 코드를 보기에도 이해하기 좋았다.

선언의 경우
class 클래스 이름 { // 클래스 키워드와 클래스이름
private: // 멤버에 대한 접근 지정자
 int raidus; // private 안에 있기에 외부에서 접근 불가
public: // 멤버에 대한 접근 지정자
 double getArea(); // public 안에 있기에 외부에서 접근 가
}

Circle donut // Circle 타입의 donut 객체 생성
dount.getArea(); // 객체와 멤버 사이에 . 연산자로 멤버 호출

<생성자>
객체가 생성되는 시점에서 자동으로 호출된다.
장점은 객체를 생성하면서 초기 값을 넣어 객체를 생성할 수 있다는 것이며
매개 변수를 가지지 않는 생성자와 매개 변수를 가지는 생성자를 만들 수 있다.
그리고 생성 당시에 해당하는 생성자 하나만 호출한다.
이걸 사용하다면 여러가지 상황에서 객체를 생성해야 할 때와
회원가입시 어떤 내용을 입력하지 않아도 아이디를 생성할 수 있게 도와줄 수 있는 부분이
생성자라고 생각하고 생각보다 많이 사용할 수 있을 것 같다.

그리고 여러 생성자를 생성하다보니 중복 작성된 코드들이 존재하게 된다.
그럴 때 유용한 것이 위임 생성자이다.
수업 외에 공부를 하면서 여러가지 코드 문제를 풀면서 느낌점은
위임 생성자를 사용하며 코드의 최적화를 할 수 있고 불필요한 부분의 시간 소요가 단축 되었다.

Circle::Circle() {
    radius = 1;
}

Circle::Circle(int r) {
    radius = r
}

위 처럼 같은 내용에 코드가 겹치 때는

Circle::Circle() : Circle(1) { } // 위임 생성자

Circle::Circle(int r) { // 타켓 생성자 
    radius = r
}

이렇게 줄일 수 있다는 것이다.

단, 클래스 안에 생성자가 선언되어 있다면 기본 생성자를 생성하지 않기 때문에
Circle donut;
을 작성하면 컴파일 오류가 나기 때문에 항상 코드를 작성할 땐
객체의 구조를 잘 파악하고 객체를 생성해야 한다!!!!!

<소멸자>
객체가 생성이 되었다며 메모리 소멸을 위한 소멸자도 존재한다.
객체의 생성과 소멸을 사용자가 원하는 시점에 할 수 있다는 것은
C++의 장점이라고 생각한다.
소멸이 자연스럽게 되는 자바, c#의 경우 원하지 않을 때 객체가 소멸 되는 경우도 있지만
C++은 그렇지 않기에 내가 원하는 타이밍까지 해당 객체를 이용할 수 있다는 것이 매우 장점이라고 본다.

소멸자는 생성자와 비슷하게 만들어진다
Circle::~Circle() { }

이 구조를 꼭 기억할 것!!

<인라인 inline 함수>
컴파일러에 의해 이루어지는 함수
프로그램의 실행 속도 개선

수업 시간에 배운 인라인 함수의 목적
-> C++ 프로그램의 실행 속도 향상

내가 생각하는 인라인 코드를 봤을 땐 이해가 된다.
그러나 컴파일에서 작동하는 부분이기 때문에
코드를 작성하는 사용자가 정확한 코드 내용 이해와 인라인에 대한 이해가 높아야 잘 이용할 수 있을 것 같기에
인라인 함수는 많은 연습을 통해 자연스럽게 사용해야 할 것 같다.

<C와 C++ 구조체>
C 구조체 생성 : struct structName stObj;
C++ 구조체 생성 : StructName stObjl
C++ 구조체에서는 struct 키워드 생략 가능

C++의 구조체는 C와 호환을 위해 만들어졌다.

단, 조심할 것이 있다.
C++ 클래스의 경우 디폴트 접근 지정자는 private이지만
구조체의 경우 디폴트 접근 지정자는 public이다.

C++을 자주 사용하면 C 언어의 구조체에서 객체 생성 부분을 헷갈릴 것 같다는 조원과의 이야기가 있었다.

<C++ 프로그램 작성법>
이미 C++을 어느정도 접했던 저는 분리 작성법을 알고 있었다.
클래스 선언부인 .h 파일과 클래스 구현분 .cpp 파일
아무래도 객체를 생성하고 자유롭게 재사용 해야 하기에 필요한 방법이다.

그래서 실제로 프로그래밍을 할 때 헤더 파일은 왼쪽에 cpp 파일은 오른쪽에 두고
헤더 파일 클래스에 멤버 변수, 멤버 함수 순으로 cpp 파일에 코딩한다.

다만 전에는 헤더 파일 중복을 생각하지 않고 요리조리 잘 피해서인지
헤더 파일 중복건이 없었지만
이번 수업을 통해 배운

#ifndef ~~
#define ~~
~~

#endif ~~
이 구문은 앞으로의 객체지향 프로그래밍을 할 때 많은 도움이 될거라 생각한다.

아무래도 구조를 잘 짠다고 해도
서로의 객체끼리 영향을 줄 것이고
그러다보면 main.cpp에서 분명 충돌이 날 경우가 많다.

그것을 막기 위해 위 구문에 클래스의 이름으로 선언하여
조건 컴파일 문을 이용하는 것이 매우 중요한 방법이라 생각하며
우리 조는 이 부분에 별 표시를 매우 많이 했습니다
