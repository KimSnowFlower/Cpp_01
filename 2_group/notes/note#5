작성자 : 202004035 김평화

객체 지향 상속 = 유전적 상속
-> 부모가 자식을 낳으면 유전적으로 물려 받는 것처럼 객체 지향은 부모 클래스의 멤버 함수, 변수를 물려 받는다 (접근 지정자에 따라 다름)

※클래스 사이에서 상속관계를 정의한 것. 객체 사이에 상속 관계가 아니다.

기본 클래스 (base class) : 부모 클래스
파생 클래스 (derived class) : 자식 클래스

파생(자식) 클래스가 기본(부모) 클래스의 속성과 기능을 물려 받는 것

상속 장점:
1. 간결한 클래스 작성
2. 클래스 간의 계층적 분류 및 관리의 용이함
3. 클래스 재사용과 확장을 통한 소프트웨어 생산성 향상

상속 선언 방법
부모 클래스 : Person
자식 클래스 : Student

class Person { // 부모 클래스
private:
~~
public:
~~
};

// class 자식 클래스명 : 접근 지정자 부모클래스명
class Student : public Person { // 자식 클래스가 부모 클래스를 상속 받음
private:
~~
public:
~~
};
※자식 클래스는 부모 클래스의 접근 지정자에 따라 사용할 수 있다. (private, protected, public에 따라 사용 가능)

업 캐스팅, 다운 캐스팅은 무엇인가?

업 캐스팅
-> 파생 클래스 포인터가 기본 클래스 포인터로 치환된 것

다운 캐스팅
-> 기본 클래스 포인터가 파생 클래스 포인터로 치환된 것

내가 생각하는 둘의 차이점
1. 업 캐스팅은 파생 클래스의 멤버를 사용할 수 없어지는 것이고 다운 캐스팅은 파생 클래스의 멤버까지 접근 가능하다.
-> 개인적으로는 기능을 포기하고 올라가냐 내려가냐의 개념으로 외우는 것이 편했다.
2. 업 캐스팅은 포인터로 치환하면 간단하지만 다운 캐스팅은 강제 타입 변환이 꼭 필요하다.
-> 아무래도 부모 클래스를 상속 받은 파생 클래스가 많을 수 있기 때문에 타입 변환을 꼭 해줘야 정확한 파생 클래스로 다운 캐스팅이 가능하다.
※이 둘의 차이점은 생각보다 쉽게 까먹을 수 있기 때문에 잘 기억하고 숙지해야 한다.

접근 지정자
private 멤버:
-선언된 클래스 내에서만 접근 가능
-파생 클래스에서도 기본 클래스의 private 멤버 직접 접근 불가

public 멤버:
-선언된 클래스나 외부 어떤 클래스, 모든 외부 함수에 접근 허용
-파생 클래스에서 기본 클래스의 public 멤버 접근 가능

protected 멤버:
-선언된 클래스에서 접근 가능
-파생 클래스에서만 접근 허용

public, private은 우리가 흔히 많이 사용하기에 잘 알고 있는 부분이다.
하지만 protected는 예제로도 많이 나오지 않고
익숙하지 않은 접근 지정자이다.

protected 쉽게 이해하기
1. 외부 함수 접근 불가X
2. 다른 클래스에서 접근 불가X
3. 파생 클래스에서는 접근 가능O
-> 파생 클래스에서만 접근 가능하다는 점을 유의해야 한다!!! 매우 중요!!!

생성자, 소멸자 실행 순서
A 클래스 -> A의 자식 B클래스 -> B의 자식 C클래스

생성자 순서
-> A 클래스 -> B 클래스 -> C 클래스
소멸자
-> C 클래스 - > B 클래스 -> A 클래스

컴파일러에 의해 묵시적으로 기본 클래스의 생성자를 선택하는 경우
-파생 클래스의 생성자에서 기본 클래스의 기본 생성자 호출

class A{
public:
  A()~
  A(int x)~
};

class B : public A{
public:
 B()~
};

이 경우 묵시적으로 파생 클래스에 생성자가 부모 클래스의 기본 생성자를 선택한다.
그렇다면 내가 원하는 생성자를 호출 하려면 어떤 방법을 선택해야 하나??
수업 시간에 배운 명시적 방법을 해야 한다.

class A{
public:
  A()~
  A(int x)~
};

class B : public A{
public:
 B()~
 B(int x) : A(x+3)~ // 명시적 호출
};
-> 명시적으로 호출하면 기본 클래스의 기본 생성자가 아닌 해당하는 생성자를 호출한다.

상속의 종류 - 상속지정
상속 선언 시에도 상속 지정자로 public, private, protected가 있다.

public
-> 기본 클래스의 protected, public 멤버 속성을 그대로 계승

private
-> 기본 클래스의 protected, public 멤버를 private으로 계승

protected
-> 기본 클래스의 protected, public 멤버를 protected로 계승

※기본적으로 public과 protected는 파생에서 사용하는 것은 동일하지만 protected는 외부 함수에서 접근을 못 하기에
처음에 클래스 간의 구조를 잘 고려야 해야 한다. 그리고 private은 부모 클래스의 멤버를 모두 private으로 계승하기 때문에
나라면 전반적으로 프로그램의 흐름을 관리하는 Manager 같은 부모 클래스를 만들고 그 아래에 자식에게 넘길 때 Manager는 기본적으로
고정적인 부분들이 있어야 하기 때문에 그때 private으로 부모 클래스의 접근을 막아 버리고 유동적으로 사용할 수 있게 get, set 함수를 만들 것 같다.

다중 상속은 말 그래도 파생 클래스가 두개 이상의 기본 클래스를 상속 받는 것이다.
근데 여기서 문제가 하나있다.

우리가 클래스 구조를 만들다 보면 분명 같은 부모를 상속 받는 파생 클래스가 존재한다.
그런데 위에 같은 파생 클래스를 다중 상속 받는 클래스도 존재할 수 있다.
예시로는 수업 시간에 배운 8장 상속에서 수업자료 36장에 예시가 있는데
BaseIO : 부모 클래스
In : BaseIO의 파생 클래스
Out : BaseIO의 파생 클래스
InOut : In, Out을 다종 상속 받은 파생 클래스

이와 같이 InOut 클래스는 다중 상속을 받았고 파생 클래스라서
BaseIO의 멤버도 충분히 접근히 가능하지만 문제는
어떤 부모 클래스를 통해서 BaseIO를 접근 해야 하는지 모호하다.

그렇기 때문에 객체 지향에는 가상 상속이라는 것이 존재한다.
키워드는 virtual이다.
가상 상속은 기본 클래스의 멤버가 중복하여 생성되는 것을 방지하기 위한 방법이다.

사용 방법은 파생 클래스의 선언문에서 기본 클래스 앞에 virtual로 선언하면 되며
이것은 파생 클래스의 객체가 생성될 때 기본 클래스의 메범는 오직 한번 생성한다.

class In : virtual BaseIO {
~~
};

물론 클래스 구조를 만들다 보면 다중 상속 받은 파생 클래스의 부모의 부모 클래스가 겹치는 현상이 나타날 수 있다.
하지만 내가 지금까지 C++을 이용해 코딩했을 때 기준으로 봤을 때 너무 많은 virtual을 쓰는 것이 좋은지는 모르겠다.
오히려 적당한 부분에 어쩔 수 없는 경우에는 사용하겠지만 아무래도 사람이 사용하다보면 virtual이 편해서
클래스의 90퍼센트를 virtual을 만드는 것보다는 30~40퍼센트로 줄이는 것이 중요하다고 생각하며
이번 수업 내용 중에서 제일 킵 포인트이라는 생각이 든다.
