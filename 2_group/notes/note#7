작성자 : 20204035 김평화

중복 함수의 코드 중복
- 같은 내용에 코드를 가지고 매개 변수만 다른게 만듬
=> 이렇게 만들면 중복적인 내용의 함수를 필요할 때마다 만들게 됨. 그러면 코드가 너무 가독성과 유지보수가 힘듬

제네릭 == 일반화
- 함수 or 클래스를 일반화
- 매개 변수 타입을 지정하여 계속해서 사용 가능

템플릿
- 키워드 : template <class T> 등
- C++에서 일반화하는 방법
- 템플릿을 이용하여 함수나 클래스를 많이 사용

=> 템플릿을 왜 사용하는지에 대한 생각 : 
우리가 사용하는 라이브러리, 함수 등 기본적으로 제공하는 클래스 함수들이
템플릿을 이용하고 있다. 그럼 왜 이용하는 것일까?
아무래도 프로그래밍은 다양한 데이터 타입이 존재하기 때문에
그 데이터 타입에 맞추어 함수나 클래스를 맞추면 사용자나 제공자 모두 힘들고
편하고 사용하기 좋고 유용하게 사용할 수 있다.
(이 노트 작성자도 라이브러리 제작 때 템플릿을 유용하게 사용했다.)

선언 예시
template<class T>
void mySwap(T &a, T &b) {
  T tmp;
  tmp = a;
  a = b;
  b = tmp;
}

제너릭 타입 T를 선언하여 사용하기 때문에
매개변수만 다르고 코드가 동일한 내용들은 템플릿 클래스 혹은 함수로
합치면 코드 최적화가 가능하다.

구체화
- 템플릿의 제네렉 타입에 구체적인 타입 지정
EX) 만일 int로 호출하면 T에 int를 대입하여 구체화된 소스 코드가 생성되고 컴파일 후 실행된다.
*단, 두 개의 매개 변수의 타입이 서로 다를 경우 구체화 오류가 발생한다. 이 점은 꼭 유의 할 것!!!!

지금까지 내용 정리를 하면 결국 템플릿은 함수 코드의 재사용이 매우 장점이다.
단, 단점은 포팅에 취약하고 컴파일 오류 메시지 빈약, 디버깅에 많은 어려움이 있다느 것이다.
=> 장점만 알기보다 단점도 알고 있을 것

C++ Standard Template Library = STL
- 이름에서 보이는 것 처럼 표준 템플릿 라이브러리이며 많은 제네럭 클래스, 함수가 포함
- 구성 : 컨테이너(템플릿 클래스), itreator(포인터), 알고리즘(템플릿 함수)
- 헤더 파일 : #include<~~> ex) vector, list

vector와 map은 강의자료를 보고 꼭 직접 코딩 해보길 추천합니다.

대표적으로 제일 많이 사용하는 STL은 개인적으로 vector, map, list
수업 시간에 배운 STL : vector, map 그리고 STL 알고리즘 하수 sort
vector와 map 함수를 보면 생각보다 공통적인 함수명과 기능이 비슷한 것을 알 수 있다.
그렇다면 이 클래스들의 구조도와 부모와의 관계를 어느정도 짐작할 수 있다.
=> 내 생각은 STL의 기본적인 부모클래스를 상속받아 여러가지의 클래스들로 파생 된 모습인 것이라 생각한다.
   그렇기에 동일한 이름의 가상함수가 존재할 것이라 추측한다.

sort함수는 생각보다 단순하고 지난 학기 자료구조 수업을 들었다면 어느정도 알 수 있는 부분이기에 자세한 설명은 X
=> 템플릿 함수이며 전역함수 이고 iterator와 함께 작동
   #include <algorithm>
   첫 번째 매개 변수 : 소팅을 시작한 원소의 주소
   두 번째 매개 변수 : 소팅 범위의 마지막 원소 다음 주소

iterator
- 반복자, 컨테이너의 원소를 가리키는 포인터
- 이 내용도 지난 학기 자료구조 수업에서 구조체를 통해 리스트 구성을 했다면 충분히 이해할 만한 내용
- 구조체로 리스트, 큐, 스택 등을 구현할 때 삽입된 자리의 위치나 시작, 마지막 노드에 위치를 알기 위해 포인터 변수를 활용한 것 처럼
  iterator를 사용할 수 있다

auto
- auto는 지난 학기 java 수업 때 var 키워드 처럼 타입을 추론하여 변수를 선언하는 것이다.
- auto의 사용 예시는 변수 선언 때 데이터 타입을 지정하는거 대신 auto를 작성하고 변수명 뒤에 꼭 초기화 해주길 바란다.

C++ 람다식 (수업 시간에 제대로 진행하지 못해서 조금 생략하여 작성)
캡쳐 리스트, 매개변수 리스트, 리턴 타입, 함수 바디
[        ], (            ),->        {         }

ex)
[](int x, int y)->int { return x+y; }

double pi = 3.14;
auto calc = [pi](int r) -> double { return pi*r*r; }

캡쳐 리스트 : 사용하고자 하는 함수의 바깥의 변수 목록
매개변수 리스트 : 보통 함수의 매개변수 리스트와 동일
리턴 타입 : 생략 가능
함수 바디 : 람다식의 함수 코드

람다식을 이용하면 대략 한줄짜리 코드로 하나의 함수를 구현할 수 있다.
짧은 연산을 이용할 때 유용하다 생각한다!!
